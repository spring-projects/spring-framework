[[webflux-ann-requestheader]]
= `@RequestHeader`

[.small]#xref:web/webmvc/mvc-controller/ann-methods/requestheader.adoc[See equivalent in the Servlet stack]#

You can use the `@RequestHeader` annotation to bind a request header to a method argument in a
controller.

The following example shows a request with headers:

[literal]
[subs="verbatim,quotes"]
----
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
----

The following example gets the value of the `Accept-Encoding` and `Keep-Alive` headers:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes"]
----
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
		//...
	}
----
<1> Get the value of the `Accept-Encoding` header.
<2> Get the value of the `Keep-Alive` header.

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes"]
----
	@GetMapping("/demo")
	fun handle(
			@RequestHeader("Accept-Encoding") encoding: String, // <1>
			@RequestHeader("Keep-Alive") keepAlive: Long) { // <2>
		//...
	}
----
<1> Get the value of the `Accept-Encoding` header.
<2> Get the value of the `Keep-Alive` header.
======

Type conversion is applied automatically if the target method parameter type is not
`String`. See xref:web/webflux/controller/ann-methods/typeconversion.adoc[Type Conversion].

When a `@RequestHeader` annotation is used on a `Map<String, String>`,
`MultiValueMap<String, String>`, or `HttpHeaders` argument, the map is populated
with all header values.

TIP: Built-in support is available for converting a comma-separated string into an
array or collection of strings or other types known to the type conversion system. For
example, a method parameter annotated with `@RequestHeader("Accept")` may be of type
`String` but also of `String[]` or `List<String>`.

We can use `@RequestHeader` as a meta-annotation, so you can create custom annotations for repeatedly used headers, like the `Accept-Language` header.
The next example demonstrates how we could do this with an annotation named `@LanguageRequestHeader`:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes"]
----
@Target({ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@RequestHeader(value = HttpHeaders.ACCEPT_LANGUAGE, defaultValue = "en")
public @interface LanguageRequestHeader {}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes"]
----
@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@RequestHeader(value = HttpHeaders.ACCEPT_LANGUAGE, defaultValue = "en")
annotation class LanguageRequestHeader
----
======

Now that `@LanguageRequestHeader` has been specified, we can use it to signal Spring to resolve our `@LanguageRequestHeader` from the current `Accept-Language` request header:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes"]
----
@GetMapping("/product")
public Flux<Product> fetchProduct(@LanguageRequestHeader String lang) {

	// .. fetch product and return them ...
}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes"]
----
@GetMapping("/product")
fun fetchProduct(@LanguageRequestHeader lang: String): Flux<Product> {

    // .. fetch product and return them ...
}
----
======


TIP: We can replace the lang parameter type from `String` to `java.util.Locale` or to your own Language enum, and Spring will handle the conversion of the header value. You may need to implement the xref:core/validation/convert.adoc[`Converter`] interface and register it.
