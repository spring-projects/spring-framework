
= Dependencies

A typical enterprise application does not consist of a single object (or bean in the Spring parlance).
Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application.
This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.

== Dependency injection

_Dependency injection_ (DI) is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method.
The container then _injects_ those dependencies when it creates the bean.
This process is fundamentally the inverse, hence the name _Inversion of Control_ (IoC), of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes, or the _Service
      Locator_ pattern.

Code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies.
The object does not look up its dependencies, and does not know the location or class of the dependencies.
As such, your classes become easier to test, in particular when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.

DI exists in two major variants, <<beans-constructor-injection,Constructor-based dependency
      injection>> and <<beans-setter-injection,Setter-based
      dependency injection>>.

=== Constructor-based dependency injection

_Constructor-based_ DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency.
Calling a `static` factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a `static` factory method similarly.
The following example shows a class that can only be dependency-injected with constructor injection.
Notice that there is nothing _special_ about this class, it is a POJO that has no dependencies on container specific interfaces, base classes or annotations.

[source,java]
----
public class SimpleMovieLister {

  // the SimpleMovieLister has a dependency on a MovieFinder
  private MovieFinder movieFinder;

  // a constructor so that the Spring container can 'inject' a MovieFinder
  public SimpleMovieLister(MovieFinder movieFinder) {
      this.movieFinder = movieFinder;
  }

  // business logic that actually 'uses' the injected MovieFinder is omitted...
}
----

==== Constructor argument resolution

Constructor argument resolution matching occurs using the argument's type.
If no potential ambiguity exists in the constructor arguments of a bean definition, then the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated.
Consider the following class:

[source,java]
----
package x.y;

public class Foo {

  public Foo(Bar bar, Baz baz) {
      // ...
  }
}
----

No potential ambiguity exists, assuming that [class]`Bar` and [class]`Baz` classes are not related by inheritance.
Thus the following configuration works fine, and you do not need to specify the constructor argument indexes and/or types explicitly in the `<constructor-arg/>` element.

[source,xml]
----
<beans>
  <bean id="foo" class="x.y.Foo">
      <constructor-arg ref="bar"/>
      <constructor-arg ref="baz"/>
  </bean>

  <bean id="bar" class="x.y.Bar"/>
  <bean id="baz" class="x.y.Baz"/>

</beans>
----

When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example).
When a simple type is used, such as `<value>true<value>`, Spring cannot determine the type of the value, and so cannot match by type without help.
Consider the following class:

[source,java]
----
package examples;

public class ExampleBean {

  // No. of years to the calculate the Ultimate Answer
  private int years;

  // The Answer to Life, the Universe, and Everything
  private String ultimateAnswer;

  public ExampleBean(int years, String ultimateAnswer) {
      this.years = years;
      this.ultimateAnswer = ultimateAnswer;
  }
}
----

===== Constructor argument type matching

In the preceding scenario, the container _can_ use type matching with simple types if you explicitly specify the type of the constructor argument using the `type` attribute.
For example:

[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">
<constructor-arg type="int" value="7500000"/>
<constructor-arg type="java.lang.String" value="42"/>
</bean>
----

===== Constructor argument index

Use the `index` attribute to specify explicitly the index of constructor arguments.
For example:

[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">
<constructor-arg index="0" value="7500000"/>
<constructor-arg index="1" value="42"/>
</bean>
----

In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type.
Note that the _index is
            0 based_.

===== Constructor argument name

As of Spring 3.0 you can also use the constructor parameter name for value disambiguation:

[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">
<constructor-arg name="years" value="7500000"/>
<constructor-arg name="ultimateanswer" value="42"/>
</bean>
----

Keep in mind that to make this work out of the box your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor.
If you can't compile your code with debug flag (or don't want to) you can use [interface]`@ConstructorProperties` JDK annotation to explicitly name your constructor arguments.
The sample class would then have to look as follows:

[source,java]
----
package examples;

public class ExampleBean {

  // Fields omitted

  @ConstructorProperties({"years", "ultimateAnswer"})
  public ExampleBean(int years, String ultimateAnswer) {
      this.years = years;
      this.ultimateAnswer = ultimateAnswer;
  }
}
----

=== Setter-based dependency injection

_Setter-based_ DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument `static` factory method to instantiate your bean.

The following example shows a class that can only be dependency-injected using pure setter injection.
This class is conventional Java.
It is a POJO that has no dependencies on container specific interfaces, base classes or annotations.

[source,java]
----
public class SimpleMovieLister {

  // the SimpleMovieLister has a dependency on the MovieFinder
  private MovieFinder movieFinder;

  // a setter method so that the Spring container can 'inject' a MovieFinder
  public void setMovieFinder(MovieFinder movieFinder) {
      this.movieFinder = movieFinder;
  }

  // business logic that actually 'uses' the injected MovieFinder is omitted...
}
----

The [interface]`ApplicationContext` supports constructor- and setter-based DI for the beans it manages.
It also supports setter-based DI after some dependencies are already injected through the constructor approach.
You configure the dependencies in the form of a [interface]`BeanDefinition`, which you use with [interface]`PropertyEditor` instances to convert properties from one format to another.
However, most Spring users do not work with these classes directly (programmatically), but rather with an XML definition file that is then converted internally into instances of these classes, and used to load an entire Spring IoC container instance.

.Constructor-based or setter-based DI?
****
Since you can mix both, Constructor- and Setter-based DI, it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies.
Note that the use of a <<beans-required-annotation,@Required>> annotation on a setter can be used to make setters required dependencies.

The Spring team generally advocates setter injection, because large numbers of constructor arguments can get unwieldy, especially when properties are optional.
Setter methods also make objects of that class amenable to reconfiguration or re-injection later.
Management through <<jmx,JMX MBeans>> is a compelling use case.

Some purists favor constructor-based injection.
Supplying all object dependencies means that the object is always returned to client (calling) code in a totally initialized state.
The disadvantage is that the object becomes less amenable to reconfiguration and re-injection.

Use the DI that makes the most sense for a particular class.
Sometimes, when dealing with third-party classes to which you do not have the source, the choice is made for you.
A legacy class may not expose any setter methods, and so constructor injection is the only available DI.
****

=== Dependency resolution process

The container performs bean dependency resolution as follows:

[]
. The [interface]`ApplicationContext` is created and initialized with configuration metadata that describes all the beans.
  Configuration metadata can be specified via XML, Java code or annotations.
. For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method if you are using that instead of a normal constructor.
  These dependencies are provided to the bean, _when the bean is actually created_.
. Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.
. Each property or constructor argument which is a value is converted from its specified format to the actual type of that property or constructor argument.
  By default Spring can convert a value supplied in string format to all built-in types, such as `int`, `long`, `String`, `boolean`, etc.

The Spring container validates the configuration of each bean as the container is created, including the validation of whether bean reference properties refer to valid beans.
However, the bean properties themselves are not set until the bean _is actually created_.
Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created.
Scopes are defined in <<beans-factory-scopes>> Otherwise, the bean is created only when it is requested.
Creation of a bean potentially causes a graph of beans to be created, as the bean's dependencies and its dependencies' dependencies (and so on) are created and assigned.

.Circular dependencies
****
If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.

For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection.
If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a [class]`BeanCurrentlyInCreationException`.

One possible solution is to edit the source code of some classes to be configured by setters rather than constructors.
Alternatively, avoid constructor injection and use setter injection only.
In other words, although it is not recommended, you can configure circular dependencies with setter injection.

Unlike the _typical_ case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).
****

You can generally trust Spring to do the right thing.
It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time.
Spring sets properties and resolves dependencies as late as possible, when the bean is actually created.
This means that a Spring container which has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies.
For example, the bean throws an exception as a result of a missing or invalid property.
This potentially delayed visibility of some configuration issues is why [interface]`ApplicationContext` implementations by default pre-instantiate singleton beans.
At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the [interface]`ApplicationContext` is created, not later.
You can still override this default behavior so that singleton beans will lazy-initialize, rather than be pre-instantiated.

If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is _totally_ configured prior to being injected into the dependent bean.
This means that if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a <<beans-factory-lifecycle-initializingbean,configured init
        method>> or the <<beans-factory-lifecycle-initializingbean,InitializingBean
        callback method>>) are invoked.

=== Examples of dependency injection

The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions:

[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">

<!-- setter injection using the nested <ref/> element -->
<property name="beanOne"><ref bean="anotherExampleBean"/></property>

<!-- setter injection using the neater 'ref' attribute -->
<property name="beanTwo" ref="yetAnotherBean"/>
<property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

[source,java]
----
public class ExampleBean {

  private AnotherBean beanOne;
  private YetAnotherBean beanTwo;
  private int i;

  public void setBeanOne(AnotherBean beanOne) {
      this.beanOne = beanOne;
  }

  public void setBeanTwo(YetAnotherBean beanTwo) {
      this.beanTwo = beanTwo;
  }

  public void setIntegerProperty(int i) {
      this.i = i;
  }
}
----

In the preceding example, setters are declared to match against the properties specified in the XML file.
The following example uses constructor-based DI:

[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean">

<!-- constructor injection using the nested <ref/> element -->
<constructor-arg>
  <ref bean="anotherExampleBean"/>
</constructor-arg>

<!-- constructor injection using the neater 'ref' attribute -->
<constructor-arg ref="yetAnotherBean"/>

<constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

[source,java]
----
public class ExampleBean {

  private AnotherBean beanOne;
  private YetAnotherBean beanTwo;
  private int i;

  public ExampleBean(
      AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
      this.beanOne = anotherBean;
      this.beanTwo = yetAnotherBean;
      this.i = i;
  }
}
----

The constructor arguments specified in the bean definition will be used as arguments to the constructor of the [class]`ExampleBean`.

Now consider a variant of this example, where instead of using a constructor, Spring is told to call a `static` factory method to return an instance of the object:

[source,xml]
----
<bean id="exampleBean" class="examples.ExampleBean"
    factory-method="createInstance">
<constructor-arg ref="anotherExampleBean"/>
<constructor-arg ref="yetAnotherBean"/>
<constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

[source,java]
----
public class ExampleBean {

  // a private constructor
  private ExampleBean(...) {
    ...
  }
  
  // a static factory method; the arguments to this method can be
  // considered the dependencies of the bean that is returned,
  // regardless of how those arguments are actually used.
  public static ExampleBean createInstance (
          AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

      ExampleBean eb = new ExampleBean (...);
      // some other operations...
      return eb;
  }
}
----

Arguments to the `static` factory method are supplied via `<constructor-arg/>` elements, exactly the same as if a constructor had actually been used.
The type of the class being returned by the factory method does not have to be of the same type as the class that contains the `static` factory method, although in this example it is.
An instance (non-static) factory method would be used in an essentially identical fashion (aside from the use of the `factory-bean` attribute instead of the `class` attribute), so details will not be discussed here.

== Dependencies and configuration in detail

As mentioned in the previous section, you can define bean properties and constructor arguments as references to other managed beans (collaborators), or as values defined inline.
Spring's XML-based configuration metadata supports sub-element types within its `<property/>` and `<constructor-arg/>` elements for this purpose.

=== Straight values (primitives, `Strings`, and so on)

The `value` attribute of the `<property/>` element specifies a property or constructor argument as a human-readable string representation.
<<beans-beans-conversion,As mentioned previously>>, JavaBeans `PropertyEditors` are used to convert these string values from a [class]`String` to the actual type of the property or argument.

[source,xml]
----
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">

<!-- results in a setDriverClassName(String) call -->
<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
<property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
<property name="username" value="root"/>
<property name="password" value="masterkaoli"/>
</bean>
----

The following example uses the <<beans-p-namespace,p-namespace>> for even more succinct XML configuration.

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:p="http://www.springframework.org/schema/p"
     xsi:schemaLocation="http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd">

<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
      destroy-method="close"
      p:driverClassName="com.mysql.jdbc.Driver"
      p:url="jdbc:mysql://localhost:3306/mydb"
      p:username="root"
      p:password="masterkaoli"/>

</beans>
----

The preceding XML is more succinct; however, typos are discovered at runtime rather than design time, unless you use an IDE such as <<,IntelliJ IDEA>> or the <<,SpringSource Tool
        Suite>> (STS) that support automatic property completion when you create bean definitions.
Such IDE assistance is highly recommended.

You can also configure a [class]`java.util.Properties` instance as:

[source,xml]
----
<bean id="mappings"
    class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">

 <!-- typed as a java.util.Properties -->
 <property name="properties">
    <value>
       jdbc.driver.className=com.mysql.jdbc.Driver
       jdbc.url=jdbc:mysql://localhost:3306/mydb
    </value>
 </property>
</bean>
----

The Spring container converts the text inside the `<value/>` element into a [class]`java.util.Properties` instance by using the JavaBeans [interface]`PropertyEditor` mechanism.
This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested `<value/>` element over the `value` attribute style.

==== The `idref` element

The `idref` element is simply an error-proof way to pass the _id_ (string value - not a reference) of another bean in the container to a `<constructor-arg/>` or `<property/>` element.

[source,xml]
----
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
  <property name="targetName">
      <idref bean="theTargetBean" />
  </property>
</bean>
----

The above bean definition snippet is _exactly_ equivalent (at runtime) to the following snippet:

[source,xml]
----
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
  <property name="targetName" value="theTargetBean" />
</bean>
----

The first form is preferable to the second, because using the `idref` tag allows the container to validate _at deployment time_ that the referenced, named bean actually exists.
In the second variation, no validation is performed on the value that is passed to the `targetName` property of the `client` bean.
Typos are only discovered (with most likely fatal results) when the `client` bean is actually instantiated.
If the `client` bean is a <<beans-factory-scopes,prototype>> bean, this typo and the resulting exception may only be discovered long after the container is deployed.

Additionally, if the referenced bean is in the same XML unit, and the bean name is the bean _id_, you can use the `local` attribute, which allows the XML parser itself to validate the bean id earlier, at XML document parse time.

[source,xml]
----
<property name="targetName">
 <!-- a bean with id 'theTargetBean' must exist; otherwise an exception will be thrown -->
 <idref bean="theTargetBean"/>
</property>
----

A common place (at least in versions earlier than Spring 2.0) where the <idref/> element brings value is in the configuration of <<aop-pfb-1,AOP interceptors>> in a [class]`ProxyFactoryBean` bean definition.
Using <idref/> elements when you specify the interceptor names prevents you from misspelling an interceptor id.

=== References to other beans (collaborators)

The `ref` element is the final element inside a `<constructor-arg/>` or `<property/>` definition element.
Here you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container.
The referenced bean is a dependency of the bean whose property will be set, and it is initialized on demand as needed before the property is set.
(If the collaborator is a singleton bean, it may be initialized already by the container.) All references are ultimately a reference to another object.
Scoping and validation depend on whether you specify the id/name of the other object through the `bean`,`local,` or `parent` attributes.

Specifying the target bean through the `bean` attribute of the `<ref/>` tag is the most general form, and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file.
The value of the `bean` attribute may be the same as the `id` attribute of the target bean, or as one of the values in the `name` attribute of the target bean.

[source,xml]
----
<ref bean="someBean"/>
----

Specifying the target bean through the `local` attribute leverages the ability of the XML parser to validate XML id references within the same file.
The value of the `local` attribute must be the same as the `id` attribute of the target bean.
The XML parser issues an error if no matching element is found in the same file.
As such, using the local variant is the best choice (in order to know about errors as early as possible) if the target bean is in the same XML file.

[source,xml]
----
<ref bean="someBean"/>
----

Specifying the target bean through the `parent` attribute creates a reference to a bean that is in a parent container of the current container.
The value of the `parent` attribute may be the same as either the `id` attribute of the target bean, or one of the values in the `name` attribute of the target bean, and the target bean must be in a parent container of the current one.
You use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that will have the same name as the parent bean.

[source,xml]
----
<!-- in the parent context -->
<bean id="accountService" class="com.foo.SimpleAccountService">
  <!-- insert dependencies as required as here -->
</bean>
----

[source,xml]
----
<!-- in the child (descendant) context -->
<bean id="accountService"  <-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/>  <!-- notice how we refer to the parent bean -->
    </property>
  <!-- insert other configuration and dependencies as required here -->
</bean>
----

=== Inner beans

A `<bean/>` element inside the `<property/>` or `<constructor-arg/>` elements defines a so-called .

[source,xml]
----
<bean id="outer" class="...">
<!-- instead of using a reference to a target bean, simply define the target bean inline -->
<property name="target">
  <bean class="com.example.Person"> <!-- this is the inner bean -->
    <property name="name" value="Fiona Apple"/>
    <property name="age" value="25"/>
  </bean>
</property>
</bean>
----

An inner bean definition does not require a defined id or name; the container ignores these values.
It also ignores the `scope` flag.
Inner beans are _always_ anonymous and they are _always_ created with the outer bean.
It is _not_ possible to inject inner beans into collaborating beans other than into the enclosing bean.

=== Collections

In the `<list/>`, `<set/>`, `<map/>`, and `<props/>` elements, you set the properties and arguments of the Java [interface]`Collection` types [interface]`List`, [interface]`Set`, [interface]`Map`, and [interface]`Properties`, respectively.

[source,xml]
----
<bean id="moreComplexObject" class="example.ComplexObject">
<!-- results in a setAdminEmails(java.util.Properties) call -->
<property name="adminEmails">
  <props>
      <prop key="administrator">administrator@example.org</prop>
      <prop key="support">support@example.org</prop>
      <prop key="development">development@example.org</prop>
  </props>
</property>
<!-- results in a setSomeList(java.util.List) call -->
<property name="someList">
  <list>
      <value>a list element followed by a reference</value>
      <ref bean="myDataSource" />
  </list>
</property>
<!-- results in a setSomeMap(java.util.Map) call -->
<property name="someMap">
  <map>
      <entry key="an entry" value="just some string"/>
      <entry key ="a ref" value-ref="myDataSource"/>
  </map>
</property>
<!-- results in a setSomeSet(java.util.Set) call -->
<property name="someSet">
  <set>
      <value>just some string</value>
      <ref bean="myDataSource" />
  </set>
</property>
</bean>
----

_The value of a map key or value, or a set value, can also
        again be any of the following elements:_

[source,xml]
----
bean | ref | idref | list | set | map | props | value | null
----

==== Collection merging

As of Spring 2.0, the container supports the _merging_ of collections.
An application developer can define a parent-style `<list/>`, `<map/>`, `<set/>` or `<props/>` element, and have child-style `<list/>`, `<map/>`, `<set/>` or `<props/>` elements inherit and override values from the parent collection.
That is, the child collection's values are the result of merging the elements of the parent and child collections, with the child's collection elements overriding values specified in the parent collection.

_This section on merging discusses the parent-child bean
          mechanism. Readers unfamiliar with parent and child bean definitions
          may wish to read the <<beans-child-bean-definitions,relevant section>> before continuing._

The following example demonstrates collection merging:

[source,xml]
----
<beans>
<bean id="parent" abstract="true" class="example.ComplexObject">
  <property name="adminEmails">
      <props>
          <prop key="administrator">administrator@example.com</prop>
          <prop key="support">support@example.com</prop>
      </props>
  </property>
</bean>
<bean id="child" parent="parent">
  <property name="adminEmails">
      <!-- the merge is specified on the *child* collection definition -->
      <props merge="true">
          <prop key="sales">sales@example.com</prop>
          <prop key="support">support@example.co.uk</prop>
      </props>
  </property>
</bean>
<beans>
----

Notice the use of the `merge=true` attribute on the `<props/>` element of the `adminEmails` property of the `child` bean definition.
When the `child` bean is resolved and instantiated by the container, the resulting instance has an `adminEmails` [class]`Properties` collection that contains the result of the merging of the child's `adminEmails` collection with the parent's `adminEmails` collection.

[source]
----
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
----

The child [class]`Properties` collection's value set inherits all property elements from the parent `<props/>`, and the child's value for the `support` value overrides the value in the parent collection.

This merging behavior applies similarly to the `<list/>`, `<map/>`, and `<set/>` collection types.
In the specific case of the `<list/>` element, the semantics associated with the [class]`List` collection type, that is, the notion of an `ordered` collection of values, is maintained; the parent's values precede all of the child list's values.
In the case of the [interface]`Map`, [interface]`Set`, and [interface]`Properties` collection types, no ordering exists.
Hence no ordering semantics are in effect for the collection types that underlie the associated [interface]`Map`, [interface]`Set`, and [interface]`Properties` implementation types that the container uses internally.

==== Limitations of collection merging

You cannot merge different collection types (such as a [interface]`Map` and a [interface]`List`), and if you do attempt to do so an appropriate [class]`Exception` is thrown.
The `merge` attribute must be specified on the lower, inherited, child definition; specifying the `merge` attribute on a parent collection definition is redundant and will not result in the desired merging.
The merging feature is available only in Spring 2.0 and later.

==== Strongly-typed collection (Java 5+ only)

In Java 5 and later, you can use strongly typed collections (using generic types).
That is, it is possible to declare a [interface]`Collection` type such that it can only contain [class]`String` elements (for example).
If you are using Spring to dependency-inject a strongly-typed [interface]`Collection` into a bean, you can take advantage of Spring's type-conversion support such that the elements of your strongly-typed [interface]`Collection` instances are converted to the appropriate type prior to being added to the [interface]`Collection`.

[source,java]
----
public class Foo {

  private Map<String, Float> accounts;

  public void setAccounts(Map<String, Float> accounts) {
      this.accounts = accounts;
  }
}
----

[source,xml]
----
<beans>
  <bean id="foo" class="x.y.Foo">
      <property name="accounts">
          <map>
              <entry key="one" value="9.99"/>
              <entry key="two" value="2.75"/>
              <entry key="six" value="3.99"/>
          </map>
      </property>
  </bean>
</beans>
----

When the `accounts` property of the `foo` bean is prepared for injection, the generics information about the element type of the strongly-typed [class]`Map<String, Float>` is available by reflection.
Thus Spring's type conversion infrastructure recognizes the various value elements as being of type [class]`Float`, and the string values `9.99,
          2.75`, and `3.99` are converted into an actual [class]`Float` type.

=== Null and empty string values

Spring treats empty arguments for properties and the like as empty `Strings`.
The following XML-based configuration metadata snippet sets the email property to the empty [class]`String` value ("")

[source,xml]
----
<bean class="ExampleBean">
<property name="email" value=""/>
</bean>
----

The preceding example is equivalent to the following Java code: [method]`exampleBean.setEmail("")`.
The `<null/>` element handles `null` values.
For example:

[source,xml]
----
<bean class="ExampleBean">
<property name="email"><null/></property>
</bean>
----

The above configuration is equivalent to the following Java code: [method]`exampleBean.setEmail(null)`.

=== XML shortcut with the p-namespace

The p-namespace enables you to use the `bean` element's attributes, instead of nested `<property/>` elements, to describe your property values and/or collaborating beans.

Spring 2.0 and later supports extensible configuration formats <<xsd-config,with namespaces>>, which are based on an XML Schema definition.
The `beans` configuration format discussed in this chapter is defined in an XML Schema document.
However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.

The following example shows two XML snippets that resolve to the same result: The first uses standard XML format and the second uses the p-namespace.

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean name="classic" class="com.example.ExampleBean">
      <property name="email" value="foo@bar.com"/>
  </bean>

  <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="foo@bar.com"/>
</beans>
----

The example shows an attribute in the p-namespace called email in the bean definition.
This tells Spring to include a property declaration.
As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.

This next example includes two more bean definitions that both have a reference to another bean:

[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean name="john-classic" class="com.example.Person">
      <property name="name" value="John Doe"/>
      <property name="spouse" ref="jane"/>
  </bean>

  <bean name="john-modern"
      class="com.example.Person"
      p:name="John Doe"
      p:spouse-ref="jane"/>

  <bean name="jane" class="com.example.Person">
      <property name="name" value="Jane Doe"/>
  </bean>
</beans>
----

As you can see, this example includes not only a property value using the p-namespace, but also uses a special format to declare property references.
Whereas the first bean definition uses `<property name="spouse" ref="jane"/>` to create a reference from bean `john` to bean `jane`, the second bean definition uses `p:spouse-ref="jane"` as an attribute to do the exact same thing.
In this case `spouse` is the property name, whereas the `-ref` part indicates that this is not a straight value but rather a reference to another bean.

NOTE: The p-namespace is not as flexible as the standard XML format.
For example, the format for declaring property references clashes with properties that end in `Ref`, whereas the standard XML format does not.
We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time.

=== XML shortcut with the c-namespace

Similar to the <<beans-p-namespace>>, the _c-namespace_, newly introduced in Spring 3.1, allows usage of inlined attributes for configuring the constructor arguments rather then nested `constructor-arg` elements.

Let's review the examples from <<beans-constructor-injection>> with the `c` namespace:

[source,java]
----
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:c="http://www.springframework.org/schema/c"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="bar" class="x.y.Bar"/>
  <bean id="baz" class="x.y.Baz"/>

  <-- 'traditional' declaration -->
  <bean id="foo" class="x.y.Foo">
      <constructor-arg ref="bar"/>
      <constructor-arg ref="baz"/>
      <constructor-arg value="foo@bar.com"/>
  </bean>

  <-- 'c-namespace' declaration -->
  <bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com">

</beans>
----

The `c:` namespace uses the same conventions as the `p:` one (trailing `-ref` for bean references) for setting the constructor arguments by their names.
And just as well, it needs to be declared even though it is not defined in an XSD schema (but it exists inside the Spring core).

For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), one can use fallback to the argument indexes:

[source,java]
----
<-- 'c-namespace' index declaration -->
<bean id="foo" class="x.y.Foo" c:_0-ref="bar" c:_1-ref="baz">
----

NOTE: Due to the XML grammar, the index notation requires the presence of the leading ___ as XML attribute names cannot start with a number (even though some IDE allow it).

In practice, the constructor resolution <<beans-factory-ctor-arguments-resolution,mechanism>> is quite efficient in matching arguments so unless one really needs to, we recommend using the name notation through-out your configuration.

=== Compound property names

You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not `null`.
Consider the following bean definition.

[source,xml]
----
<bean id="foo" class="foo.Bar">
<property name="fred.bob.sammy" value="123" />
</bean>
----

The `foo` bean has a `fred` property, which has a `bob` property, which has a `sammy` property, and that final `sammy` property is being set to the value `123`.
In order for this to work, the `fred` property of `foo`, and the `bob` property of `fred` must not be `null` after the bean is constructed, or a  is thrown.

== Using `depends-on`

If a bean is a dependency of another that usually means that one bean is set as a property of another.
Typically you accomplish this with the <<beans-ref-element,`<ref/>`
      element>> in XML-based configuration metadata.
However, sometimes dependencies between beans are less direct; for example, a static initializer in a class needs to be triggered, such as database driver registration.
The `depends-on` attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized.
The following example uses the `depends-on` attribute to express a dependency on a single bean:

[source,xml]
----
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>

<bean id="manager" class="ManagerBean" />
----

To express a dependency on multiple beans, supply a list of bean names as the value of the `depends-on` attribute, with commas, whitespace and semicolons, used as valid delimiters:

[source,xml]
----
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
<property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
----

NOTE: The `depends-on` attribute in the bean definition can specify both an initialization time dependency and, in the case of <<beans-factory-scopes-singleton,singleton>> beans only, a corresponding destroy time dependency.
Dependent beans that define a `depends-on` relationship with a given bean are destroyed first, prior to the given bean itself being destroyed.
Thus `depends-on` can also control shutdown order.

== Lazy-initialized beans

By default,[interface]` ApplicationContext` implementations eagerly create and configure all <<beans-factory-scopes-singleton,singleton>> beans as part of the initialization process.
Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later.
When this behavior is _not_ desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as lazy-initialized.
A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.

In XML, this behavior is controlled by the `lazy-init` attribute on the `<bean/>` element; for example:

[source,xml]
----
<bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true"/>

<bean name="not.lazy" class="com.foo.AnotherBean"/>
----

When the preceding configuration is consumed by an [interface]`ApplicationContext`, the bean named `lazy` is not eagerly pre-instantiated when the [interface]`ApplicationContext` is starting up, whereas the `not.lazy` bean is eagerly pre-instantiated.

However, when a lazy-initialized bean is a dependency of a singleton bean that is _not_ lazy-initialized, the [interface]`ApplicationContext` creates the lazy-initialized bean at startup, because it must satisfy the singleton's dependencies.
The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.

You can also control lazy-initialization at the container level by using the `default-lazy-init` attribute on the `<beans/>` element; for example:

[source,xml]
----
<beans default-lazy-init="true">
  <!-- no beans will be pre-instantiated... -->
</beans>
----

== Autowiring collaborators

The Spring container can _autowire_ relationships between collaborating beans.
You can allow Spring to resolve collaborators (other beans) automatically for your bean by inspecting the contents of the [interface]`ApplicationContext`.
Autowiring has the following advantages:



* Autowiring can significantly reduce the need to specify properties or constructor arguments.
  (Other mechanisms such as a bean template <<beans-child-bean-definitions,discussed elsewhere in
            this chapter>> are also valuable in this regard.)
* Autowiring can update a configuration as your objects evolve.
  For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration.
  Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable. When using XML-based configuration metadatafootnote:[See ]
, you specify autowire mode for a bean definition with the `autowire` attribute of the `<bean/>` element.
The autowiring functionality has five modes.
You specify autowiring _per_ bean and thus can choose which ones to autowire.

.Autowiring modes
[cols="1,1", options="header"]
|===
| Mode
| Explanation
| (Default) No autowiring. Bean references must be
              defined via a ref element. Changing the default
              setting is not recommended for larger deployments, because
              specifying collaborators explicitly gives greater control and
              clarity. To some extent, it documents the structure of a
              system.

| Autowiring by property name. Spring looks for a bean
              with the same name as the property that needs to be autowired. For
              example, if a bean definition is set to autowire by name, and it
              contains a master property (that is, it has a
              setMaster(..) method), Spring looks for a
              bean definition named master, and uses it to
              set the property.

| Allows a property to be autowired if exactly one bean
              of the property type exists in the container. If more than one
              exists, a fatal exception is thrown, which indicates that you may
              not use byType autowiring for that bean. If
              there are no matching beans, nothing happens; the property is not
              set.

| Analogous to byType, but applies
              to constructor arguments. If there is not exactly one bean of the
              constructor argument type in the container, a fatal error is
              raised.
|===

With _byType_ or _constructor_ autowiring mode, you can wire arrays and typed-collections.
In such cases _all_ autowire candidates within the container that match the expected type are provided to satisfy the dependency.
You can autowire strongly-typed Maps if the expected key type is [class]`String`.
An autowired Maps values will consist of all bean instances that match the expected type, and the Maps keys will contain the corresponding bean names.

You can combine autowire behavior with dependency checking, which is performed after autowiring completes.

=== Limitations and disadvantages of autowiring

Autowiring works best when it is used consistently across a project.
If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.

Consider the limitations and disadvantages of autowiring:

* Explicit dependencies in `property` and `constructor-arg` settings always override autowiring.
  You cannot autowire so-called _simple_ properties such as primitives, [class]`Strings`, and [class]`Classes` (and arrays of such simple properties).
  This limitation is by-design.

* Autowiring is less exact than explicit wiring.
  Although, as noted in the above table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.
* Wiring information may not be available to tools that may generate documentation from a Spring container.

* Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired.
  For arrays, collections, or Maps, this is not necessarily a problem.
  However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved.
  If no unique bean definition is available, an exception is thrown.

In the latter scenario, you have several options:

* Abandon autowiring in favor of explicit wiring.
* Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false` as described in the next section.
* Designate a single bean definition as the _primary_ candidate by setting the `primary` attribute of its `<bean/>` element to `true`.
* If you are using Java 5 or later, implement the more fine-grained control available with annotation-based configuration, as described in <<beans-annotation-config>>.

=== Excluding a bean from autowiring

On a per-bean basis, you can exclude a bean from autowiring.
In Spring's XML format, set the `autowire-candidate` attribute of the `<bean/>` element to `false`; the container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as <<beans-autowired-annotation,[interface]`@Autowired`>>).

You can also limit autowire candidates based on pattern-matching against bean names.
The top-level `<beans/>` element accepts one or more patterns within its `default-autowire-candidates` attribute.
For example, to limit autowire candidate status to any bean whose name ends with _Repository,_ provide a value of *Repository.
To provide multiple patterns, define them in a comma-separated list.
An explicit value of `true` or `false` for a bean definitions `autowire-candidate` attribute always takes precedence, and for such beans, the pattern matching rules do not apply.

These techniques are useful for beans that you never want to be injected into other beans by autowiring.
It does not mean that an excluded bean cannot itself be configured using autowiring.
Rather, the bean itself is not a candidate for autowiring other beans.

== Method injection

In most application scenarios, most beans in the container are <<beans-factory-scopes-singleton,singletons>>.
When a singleton bean needs to collaborate with another singleton bean, or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other.
A problem arises when the bean lifecycles are different.
Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container only creates the singleton bean A once, and thus only gets one opportunity to set the properties.
The container cannot provide bean A with a new instance of bean B every time one is needed.

A solution is to forego some inversion of control.
You can <<beans-factory-aware,make bean A aware of the container>> by implementing the [interface]`ApplicationContextAware` interface, and by <<beans-factory-client,making a
      getBean("B") call to the container>> ask for (a typically new) bean B instance every time bean A needs it.
The following is an example of this approach:

[source,java]
----
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

 private ApplicationContext applicationContext;

 public Object process(Map commandState) {
    // grab a new instance of the appropriate Command
    Command command = createCommand();
    // set the state on the (hopefully brand new) Command instance
    command.setState(commandState);
    return command.execute();
 }

 protected Command createCommand() {
    // notice the Spring API dependency!
    return this.applicationContext.getBean("command", Command.class);
 }

 public void setApplicationContext(ApplicationContext applicationContext)
                                                                  throws BeansException {
    this.applicationContext = applicationContext;
 }
}
----

The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework.
Method Injection, a somewhat advanced feature of the Spring IoC container, allows this use case to be handled in a clean fashion.

[sidebar]
You can read more about the motivation for Method Injection in <<,this blog entry>>.

=== Lookup method injection

Lookup method injection is the ability of the container to override methods on _container managed beans_, to return the lookup result for another named bean in the container.
The lookup typically involves a prototype bean as in the scenario described in the preceding section.
The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to generate dynamically a subclass that overrides the method.

NOTE: For this dynamic subclassing to work, the class that the Spring container will subclass cannot be `final`, and the method to be overridden cannot be `final` either.
Also, testing a class that has an `abstract` method requires you to subclass the class yourself and to supply a stub implementation of the `abstract` method.
Finally, objects that have been the target of method injection cannot be serialized.
As of Spring 3.2 it is no longer necessary to add CGLIB to your classpath, because CGLIB classes are repackaged under org.springframework and distributed within the spring-core JAR. This is done both for convenience as well as to avoid potential conflicts with other projects that use differing versions of CGLIB.

Looking at the [class]`CommandManager` class in the previous code snippet, you see that the Spring container will dynamically override the implementation of the [method]`createCommand()` method.
Your [class]`CommandManager` class will not have any Spring dependencies, as can be seen in the reworked example:

[source,java]
----
package fiona.apple;

// no more Spring imports! 

public abstract class CommandManager {

 public Object process(Object commandState) {
    // grab a new instance of the appropriate Command interface
    Command command = createCommand();
    // set the state on the (hopefully brand new) Command instance
    command.setState(commandState);
    return command.execute();
 }

  // okay... but where is the implementation of this method?
 protected abstract Command createCommand();
}
----

In the client class containing the method to be injected (the [class]`CommandManager` in this case), the method to be injected requires a signature of the following form:

[source,xml]
----
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
----

If the method is `abstract`, the dynamically-generated subclass implements the method.
Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class.
For example:

[source,xml]
----
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="command" class="fiona.apple.AsyncCommand" scope="prototype">
<!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
<lookup-method name="createCommand" bean="command"/>
</bean>
----

The bean identified as _commandManager_ calls its own method [method]`createCommand()` whenever it needs a new instance of the _command_ bean.
You must be careful to deploy the `command` bean as a prototype, if that is actually what is needed.
If it is deployed as a <<beans-factory-scopes-singleton,singleton>>, the same instance of the `command` bean is returned each time.

TIP: The interested reader may also find the [class]`ServiceLocatorFactoryBean` (in the `org.springframework.beans.factory.config` package) to be of use.
The approach used in ServiceLocatorFactoryBean is similar to that of another utility class, [class]`ObjectFactoryCreatingFactoryBean`, but it allows you to specify your own lookup interface as opposed to a Spring-specific lookup interface.
Consult the JavaDocs for these classes as well as this <<,blog entry>> for additional information ServiceLocatorFactoryBean.

=== Arbitrary method replacement

A less useful form of method injection than lookup method Injection is the ability to replace arbitrary methods in a managed bean with another method implementation.
Users may safely skip the rest of this section until the functionality is actually needed.

With XML-based configuration metadata, you can use the `replaced-method` element to replace an existing method implementation with another, for a deployed bean.
Consider the following class, with a method computeValue, which we want to override:

[source,java]
----
public class MyValueCalculator {

public String computeValue(String input) {
  // some real code...
}

// some other methods...

}
----

A class implementing the [interface]`org.springframework.beans.factory.support.MethodReplacer` interface provides the new method definition.

[source,java]
----
/** meant to be used to override the existing computeValue(String)
  implementation in MyValueCalculator
*/
public class ReplacementComputeValue implements MethodReplacer {

  public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
      // get the input value, work with it, and return a computed result
      String input = (String) args[0];
      ...
      return ...;
  }
}
----

The bean definition to deploy the original class and specify the method override would look like this:

[source,xml]
----
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">

<!-- arbitrary method replacement -->
<replaced-method name="computeValue" replacer="replacementComputeValue">
  <arg-type>String</arg-type>
</replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
----

You can use one or more contained `<arg-type/>` elements within the `<replaced-method/>` element to indicate the method signature of the method being overridden.
The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class.
For convenience, the type string for an argument may be a substring of the fully qualified type name.
For example, the following all match [class]`java.lang.String`:

[source,java]
----
    java.lang.String
  String
  Str
----

Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by allowing you to type only the shortest string that will match an argument type.
